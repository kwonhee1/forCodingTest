# 150365. 미로 탈출 명령어

# 존나 절차지향적인 문제임으로 풀이 하지 않음 (풀이가 너무 절차지향적이고 하드코딩 밖에는 답이 없어보임, 다른 사이트들 또한 하드코딩 밖에는 답이 없음)
# 나중에 더러운 코드들도 사후 관리 신경써서 코딩하기 엽습 필요하면 그때 가서 연습할것!

## 문제 요구 사항 분석
주어진 n X m 격자 미로에서 시작점(x,y) 에서 목표(r,c), 탈출 이동 거리(k)가 주어질 때 이동거리 k만큼 이동해서 시작점에서 목표에 도달 가능한 모든 방법들을 주어진 방법을 통해 문자열로 나타낸다  
나타낸 문자열들중 사전(abcd)순으로 가장 빠른 문자열을 반환한다(모두 구할 필요 없음)

주어진 문자열 변경 방법  
d : 아래로 한칸 이동  
l : 왼쪽으로 한칸 이동  
u : 위로 한칸 이동  
r : 오른쪽으로 한칸 이동  
## 입력 사항
격자  :  2 <= n,m <= 50  
시작, 목표 지점 : 1<= x,y,r,c, <= n|m ( (x,y) != ((r,c) )
이동 횟수  1 <= k <= 2500
## 출력 사항
 가장 사전순으로 빠른 문자열, (단, 이동 횟수k 로 도착지점에 도착 불가능한 경우 "impossible" 반환)

## 입출력 예시
입력 1 
> n=3, m=4, x=2, y=3, r=3, x=1, k=5

출력 1
>  dllrl

입력 2
> n=3, m=3, x=1, y=2, r=3, x=3, k=2

출력 2
> dr
## 풀이 방법
1. 시작 지점에서 목표 지까지의 길을 LinkedList<Integer>로 구한다 (구한 만큼 k값을 차감한다) (남은 k값이 음수라면 "impossible")
2. 시작위치부터 시작하여 다음 단계에 따라 다음 이동 위치를 선정한다  
    다음 위치 선정 방법 (k값이 남았을때) : 
    사전순 가장 빠른 지점을 구한다(아래->왼쪽->위->오른쪽), (벽에 막혀있으면 그냥 넘긴다)
3. 해당위치로 이동하고 다음 문자열이 해당 방향 문자열과 다르다면 해당 위치에 해당 방향 문자열을 끼워 넣는다  
    끼워 넣기 방법
      1. 문자열을 끼워 넣는다
      2. 끼워넣은 반대의 문자열 변수를 += 1; left[4];
      3. k -= 2;
4. 남음 이동 위치 k가 모두 소진시 넣어야 할 나머지 방향 문자열을 위와 같은 방법으로 적절한 위치에 삽입한다  
    다음 위치 선정 방법 (k값이 모두 소진 되었을 때) :
     사전순으로 가장 빠른 변수부터 반환한다
5. 해당 LinkedList를 문자열로 변환한다
## 예상 함수
  ```
public String solution(int n, int m, int x, int y, int r, int c, int k)
protected void getDefualtPath()
protected int getNextDirection()

// linkedlist관련
protected void addAfter(int value)
protected void addBefore(int value)
protected int get(), protected Class next();
protected char getChar()
```
## 예상 시간, 공간 복잡도 2500 * 4
### 시간 복잡도 
    1. 처음 길을 탐색할 때 : 1
    2. k값이 남았을 떄 : 2500 * 4
    3. k값 모두 소진 : 2500 * 4
### 공간 복잡도 충
    1. 길을 모두 저장함 sizeof(linkedList<Integer> * 2500)